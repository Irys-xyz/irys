use clap::Parser as _;
use irys_reth::IrysEthereumNode;
use irys_types::NodeConfig;
use reth::chainspec::EthereumChainSpecParser;
use reth_chainspec::ChainSpec;
use reth_cli_commands::init_state::InitStateCommand;
use std::{
    collections::BTreeMap,
    fs::File,
    io::{BufRead as _, BufReader},
    ops::Deref as _,
    path::PathBuf,
    sync::Arc,
};

use crate::dump::StateRoot;

/// This function initializes a node's genesis state from:
/// 1.) the genesis block defined in the chainspec
/// 2.) the state dumped into `<state_path>` (this should be a JSONL file generated by backup_accounts)
/// Note: this function nulls out the genesis alloc, and sets the state root to whatever is set in the state dump
/// This is meant to be used in cases where using `alloc` is impossible, i.e if the state is very large
pub async fn init_state(
    config: NodeConfig,
    chainspec: Arc<ChainSpec>,
    state_path: PathBuf,
) -> eyre::Result<()> {
    // read the expected state root from the file
    let state_dump = File::open(&state_path)?;
    let mut reader = BufReader::new(state_dump);
    let mut line = String::new();
    reader.read_line(&mut line)?;

    let expected_state_root = serde_json::from_str::<StateRoot>(&line)?.root;

    let mut cmd = InitStateCommand::<EthereumChainSpecParser>::parse_from([
        "reth",
        "--datadir",
        config.reth_data_dir().to_str().unwrap(),
        state_path.to_str().unwrap(),
    ]);

    let mut chainspec = chainspec.deref().clone();
    // override the state root, null out the genesis allocation
    chainspec.genesis_header.set_state_root(expected_state_root);
    chainspec.genesis.alloc = BTreeMap::new();

    cmd.env.chain = Arc::new(chainspec);

    // this initializes the genesis block & the state from the state dump
    cmd.execute::<IrysEthereumNode>().await?;

    Ok(())
}
