use crate::utils::{solution_context, IrysNodeTest};
use irys_actors::{
    async_trait,
    block_discovery::{BlockDiscoveryError, BlockDiscoveryFacade as _, BlockDiscoveryFacadeImpl},
    block_producer::ledger_expiry::LedgerExpiryBalanceDelta,
    block_validation::PreValidationError,
    shadow_tx_generator::PublishLedgerWithTxs,
    BlockProdStrategy, BlockProducerInner, ProductionStrategy,
};
use irys_database::tables::IngressProofs as IngressProofsTable;
use irys_database::walk_all;
use irys_types::ingress::IngressProofV1;
use irys_types::{
    DataTransactionHeader, IngressProof, IngressProofsList, IrysBlockHeader, NodeConfig,
};
use reth_db::Database as _;

/// This test verifies that blocks containing ingress proofs from unstaked nodes are rejected.
/// It creates an EvilBlockProdStrategy that replaces real ingress proofs with proofs
/// signed by an unstaked signer, and asserts that block validation fails with
/// PreValidationError::UnstakedIngressProofSigner.
#[test_log::test(tokio::test)]
async fn slow_heavy_block_with_unstaked_ingress_proof_signer_rejected() -> eyre::Result<()> {
    struct EvilBlockProdStrategy {
        pub prod: ProductionStrategy,
        pub data_tx: DataTransactionHeader,
        pub evil_proofs: IngressProofsList,
    }

    #[async_trait::async_trait]
    impl BlockProdStrategy for EvilBlockProdStrategy {
        fn inner(&self) -> &BlockProducerInner {
            &self.prod.inner
        }

        async fn get_mempool_txs(
            &self,
            _prev_block_header: &IrysBlockHeader,
            _block_timestamp: irys_types::UnixTimestampMs,
        ) -> eyre::Result<irys_actors::block_producer::MempoolTxsBundle> {
            Ok(irys_actors::block_producer::MempoolTxsBundle {
                commitment_txs: vec![],
                commitment_txs_to_bill: vec![],
                submit_txs: vec![self.data_tx.clone()],
                publish_txs: PublishLedgerWithTxs {
                    txs: vec![self.data_tx.clone()],
                    proofs: Some(self.evil_proofs.clone()),
                },
                aggregated_miner_fees: LedgerExpiryBalanceDelta::default(),
                commitment_refund_events: vec![],
                unstake_refund_events: vec![],
            })
        }
    }

    // 1. Configure test network
    let seconds_to_wait = 20;
    let mut genesis_config = NodeConfig::testing();
    genesis_config.consensus.get_mut().chunk_size = 32;

    let test_signer = genesis_config.new_random_signer();
    genesis_config.fund_genesis_accounts(vec![&test_signer]);

    let genesis_node = IrysNodeTest::new_genesis(genesis_config.clone())
        .start_and_wait_for_packing("GENESIS", seconds_to_wait)
        .await;
    genesis_node.mine_block().await?;

    // 2. Create an UNSTAKED signer (not in genesis commitments)
    let unstaked_signer = genesis_config.new_random_signer();

    // 3. Create and post a valid data transaction
    let data = vec![42_u8; 96]; // 3 chunks of 32 bytes
    let tx = genesis_node
        .post_publish_data_tx(&test_signer, data)
        .await?;

    // 4. Upload chunks so ingress proofs can be generated
    genesis_node.upload_chunks(&tx).await?;

    // 5. Wait for ingress proofs to be generated by the staked genesis node
    genesis_node
        .wait_for_ingress_proofs_no_mining(vec![tx.header.id], seconds_to_wait)
        .await?;

    // 6. Retrieve a valid ingress proof to use as template
    let valid_proof = {
        let ro_tx = genesis_node
            .node_ctx
            .db
            .as_ref()
            .tx()
            .expect("create mdbx read tx");
        let mut found_proof = None;
        for (root, cached) in walk_all::<IngressProofsTable, _>(&ro_tx).expect("walk proofs") {
            if root == tx.header.data_root {
                found_proof = Some(cached.proof.clone());
                break;
            }
        }
        found_proof.expect("should have a valid ingress proof")
    };

    // 7. Create evil ingress proof signed by UNSTAKED signer
    let mut evil_proof = IngressProof::V1(IngressProofV1 {
        signature: Default::default(),
        data_root: valid_proof.data_root,
        proof: valid_proof.proof,
        chain_id: valid_proof.chain_id,
        anchor: valid_proof.anchor,
    });
    unstaked_signer.sign_ingress_proof(&mut evil_proof)?;

    // Verify the evil proof is signed by the unstaked signer
    assert_eq!(evil_proof.recover_signer()?, unstaked_signer.address());

    // 8. Build EvilBlockProdStrategy with the unstaked proof
    let block_prod_strategy = EvilBlockProdStrategy {
        data_tx: tx.header.clone(),
        evil_proofs: IngressProofsList(vec![evil_proof]),
        prod: ProductionStrategy {
            inner: genesis_node.node_ctx.block_producer_inner.clone(),
        },
    };

    // 9. Produce malicious block
    let (block, _adjustment_stats, transactions, _eth_payload) = block_prod_strategy
        .fully_produce_new_block_without_gossip(&solution_context(&genesis_node.node_ctx).await?)
        .await?
        .unwrap();

    // 10. Send block through BlockDiscovery for full prevalidation
    let block_discovery = BlockDiscoveryFacadeImpl::new(
        genesis_node
            .node_ctx
            .service_senders
            .block_discovery
            .clone(),
    );
    let result = block_discovery
        .handle_block(block.clone(), transactions, false)
        .await;

    // 11. Assert validation fails with UnstakedIngressProofSigner
    assert!(
        matches!(
            result,
            Err(BlockDiscoveryError::BlockValidationError(
                PreValidationError::UnstakedIngressProofSigner { .. }
            ))
        ),
        "block with ingress proof from unstaked signer should be rejected, got: {:?}",
        result
    );

    genesis_node.stop().await;
    Ok(())
}
