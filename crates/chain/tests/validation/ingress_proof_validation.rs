use crate::utils::{solution_context, IrysNodeTest};
use irys_actors::{
    async_trait,
    block_discovery::{BlockDiscoveryError, BlockDiscoveryFacade as _, BlockDiscoveryFacadeImpl},
    block_producer::ledger_expiry::LedgerExpiryBalanceDelta,
    block_validation::PreValidationError,
    shadow_tx_generator::PublishLedgerWithTxs,
    BlockProdStrategy, BlockProducerInner, ProductionStrategy,
};
use irys_database::tables::IngressProofs as IngressProofsTable;
use irys_database::walk_all;
use irys_types::ingress::{generate_ingress_proof, IngressProofV1};
use irys_types::{
    irys::IrysSigner, CommitmentTransaction, DataTransactionHeader, IngressProof,
    IngressProofsList, IrysBlockHeader, NodeConfig,
};
use reth_db::Database as _;

/// This test verifies that blocks containing ingress proofs from unstaked nodes are rejected.
/// It creates an EvilBlockProdStrategy that replaces real ingress proofs with proofs
/// signed by an unstaked signer, and asserts that block validation fails with
/// PreValidationError::UnstakedIngressProofSigner.
#[test_log::test(tokio::test)]
async fn slow_heavy_block_with_unstaked_ingress_proof_signer_rejected() -> eyre::Result<()> {
    struct EvilBlockProdStrategy {
        pub prod: ProductionStrategy,
        pub data_tx: DataTransactionHeader,
        pub evil_proofs: IngressProofsList,
    }

    #[async_trait::async_trait]
    impl BlockProdStrategy for EvilBlockProdStrategy {
        fn inner(&self) -> &BlockProducerInner {
            &self.prod.inner
        }

        async fn get_mempool_txs(
            &self,
            _prev_block_header: &IrysBlockHeader,
            _block_timestamp: irys_types::UnixTimestampMs,
        ) -> eyre::Result<irys_actors::block_producer::MempoolTxsBundle> {
            Ok(irys_actors::block_producer::MempoolTxsBundle {
                commitment_txs: vec![],
                commitment_txs_to_bill: vec![],
                submit_txs: vec![self.data_tx.clone()],
                one_year_txs: vec![],
                thirty_day_txs: vec![],
                publish_txs: PublishLedgerWithTxs {
                    txs: vec![self.data_tx.clone()],
                    proofs: Some(self.evil_proofs.clone()),
                },
                aggregated_miner_fees: LedgerExpiryBalanceDelta::default(),
                commitment_refund_events: vec![],
                unstake_refund_events: vec![],
                epoch_snapshot: irys_domain::dummy_epoch_snapshot(),
            })
        }
    }

    // 1. Configure test network
    let seconds_to_wait = 20;
    let mut genesis_config = NodeConfig::testing();
    genesis_config.consensus.get_mut().chunk_size = 32;

    let test_signer = genesis_config.new_random_signer();
    genesis_config.fund_genesis_accounts(vec![&test_signer]);

    let genesis_node = IrysNodeTest::new_genesis(genesis_config.clone())
        .start_and_wait_for_packing("GENESIS", seconds_to_wait)
        .await;
    genesis_node.mine_block().await?;

    // 2. Create an UNSTAKED signer (not in genesis commitments)
    let unstaked_signer = genesis_config.new_random_signer();

    // 3. Create and post a valid data transaction
    let data = vec![42_u8; 96]; // 3 chunks of 32 bytes
    let tx = genesis_node
        .post_publish_data_tx(&test_signer, data)
        .await?;

    // 4. Upload chunks so ingress proofs can be generated
    genesis_node.upload_chunks(&tx).await?;

    // 5. Wait for ingress proofs to be generated by the staked genesis node
    genesis_node
        .wait_for_ingress_proofs_no_mining(vec![tx.header.id], seconds_to_wait)
        .await?;

    // 6. Retrieve a valid ingress proof to use as template
    let valid_proof = {
        let ro_tx = genesis_node
            .node_ctx
            .db
            .as_ref()
            .tx()
            .expect("create mdbx read tx");
        let mut found_proof = None;
        for (root, cached) in walk_all::<IngressProofsTable, _>(&ro_tx).expect("walk proofs") {
            if root == tx.header.data_root {
                found_proof = Some(cached.proof.clone());
                break;
            }
        }
        found_proof.expect("should have a valid ingress proof")
    };

    // 7. Create evil ingress proof signed by UNSTAKED signer
    let mut evil_proof = IngressProof::V1(IngressProofV1 {
        signature: Default::default(),
        data_root: valid_proof.data_root,
        proof: valid_proof.proof,
        chain_id: valid_proof.chain_id,
        anchor: valid_proof.anchor,
    });
    unstaked_signer.sign_ingress_proof(&mut evil_proof)?;

    // Verify the evil proof is signed by the unstaked signer
    assert_eq!(evil_proof.recover_signer()?, unstaked_signer.address());

    // 8. Build EvilBlockProdStrategy with the unstaked proof
    let block_prod_strategy = EvilBlockProdStrategy {
        data_tx: tx.header.clone(),
        evil_proofs: IngressProofsList(vec![evil_proof]),
        prod: ProductionStrategy {
            inner: genesis_node.node_ctx.block_producer_inner.clone(),
        },
    };

    // 9. Produce malicious block
    let (block, _adjustment_stats, _eth_payload) = block_prod_strategy
        .fully_produce_new_block_without_gossip(&solution_context(&genesis_node.node_ctx).await?)
        .await?
        .unwrap();

    // 10. Send block through BlockDiscovery for full prevalidation
    let block_discovery = BlockDiscoveryFacadeImpl::new(
        genesis_node
            .node_ctx
            .service_senders
            .block_discovery
            .clone(),
    );
    let result = block_discovery.handle_block(block.clone(), false).await;

    // 11. Assert validation fails with UnstakedIngressProofSigner
    assert!(
        matches!(
            result,
            Err(BlockDiscoveryError::BlockValidationError(
                PreValidationError::UnstakedIngressProofSigner { .. }
            ))
        ),
        "block with ingress proof from unstaked signer should be rejected, got: {:?}",
        result
    );

    genesis_node.stop().await;
    Ok(())
}

/// This test verifies that the mempool filters out ingress proofs from unstaked signers
/// when collecting unassigned proofs for block production.
///
/// Scenario:
/// 1. Create genesis node with staked genesis signer
/// 2. Create signer B, stake them, mine to next epoch (so B is in snapshot)
/// 3. Post a data transaction and upload chunks
/// 4. Generate and store ingress proofs from both signers
/// 5. Unstake signer B and mine to next epoch (B is no longer staked)
/// 6. Query mempool's proof collection and verify only 1 proof is returned
#[test_log::test(tokio::test)]
async fn slow_heavy_mempool_filters_unstaked_ingress_proofs() -> eyre::Result<()> {
    let num_blocks_in_epoch = 4;
    let seconds_to_wait = 20;

    // 1. Configure test network with short epochs
    let mut genesis_config = NodeConfig::testing_with_epochs(num_blocks_in_epoch);
    genesis_config.consensus.get_mut().chunk_size = 32;
    // Set ingress proof requirements to 1 so we can test with fewer proofs
    genesis_config
        .consensus
        .get_mut()
        .hardforks
        .frontier
        .number_of_ingress_proofs_total = 1;
    genesis_config
        .consensus
        .get_mut()
        .hardforks
        .frontier
        .number_of_ingress_proofs_from_assignees = 0;

    // Create signer B and fund them
    let signer_b = genesis_config.new_random_signer();
    genesis_config.fund_genesis_accounts(vec![&signer_b]);

    let genesis_node = IrysNodeTest::new_genesis(genesis_config.clone())
        .start_and_wait_for_packing("GENESIS", seconds_to_wait)
        .await;
    genesis_node.mine_block().await?;

    // 2. Stake signer B
    genesis_node
        .post_stake_commitment_with_signer(&signer_b)
        .await?;

    // Mine to next epoch so signer B's stake is in the epoch snapshot
    genesis_node.mine_until_next_epoch().await?;

    // Verify signer B is now staked in the epoch snapshot
    let epoch_snapshot = genesis_node
        .node_ctx
        .block_tree_guard
        .read()
        .canonical_epoch_snapshot();
    assert!(
        epoch_snapshot.is_staked(signer_b.address()),
        "Signer B should be staked after mining to next epoch"
    );

    // 3. Unstake signer B BEFORE creating the transaction
    // This ensures the tx won't be auto-promoted while signer B is still staked
    let genesis_signer = genesis_config.signer();
    let node_consensus_config = &genesis_node.node_ctx.config.consensus;
    let unstake_anchor = genesis_node.get_anchor().await?;
    let mut unstake_tx = CommitmentTransaction::new_unstake(node_consensus_config, unstake_anchor);
    signer_b.sign_commitment(&mut unstake_tx)?;
    genesis_node.post_commitment_tx(&unstake_tx).await?;

    // Mine to include the unstake and then to next epoch so it takes effect
    genesis_node.mine_block().await?;
    genesis_node.mine_until_next_epoch().await?;

    // Verify signer B is now unstaked
    let epoch_snapshot = genesis_node
        .node_ctx
        .block_tree_guard
        .read()
        .canonical_epoch_snapshot();
    assert!(
        !epoch_snapshot.is_staked(signer_b.address()),
        "Signer B should be unstaked after mining past the unstake epoch"
    );

    // Verify genesis signer is still staked
    assert!(
        epoch_snapshot.is_staked(genesis_signer.address()),
        "Genesis signer should still be staked"
    );

    // 4. NOW create the data transaction and upload chunks
    // The tx is created after signer B unstakes, so it won't be auto-promoted with signer B's proof
    let data = vec![42_u8; 96]; // 3 chunks of 32 bytes
    let tx = genesis_node
        .post_publish_data_tx(&genesis_signer, data.clone())
        .await?;

    genesis_node.upload_chunks(&tx).await?;

    // Wait for chunks to be cached and the genesis node to auto-generate its ingress proof
    genesis_node.wait_for_chunk_cache_count(3, 10).await?;

    // Wait for genesis node to generate its ingress proof
    genesis_node
        .wait_for_ingress_proofs_no_mining(vec![tx.header.id], seconds_to_wait)
        .await?;

    // 5. Generate and inject a proof from signer B (who is NOW unstaked)
    // This simulates having an old proof from when they were staked
    let consensus_config = genesis_config.consensus_config();
    let chain_id = consensus_config.chain_id;
    let anchor = genesis_node.get_anchor().await?;
    let chunk_size = consensus_config.chunk_size as usize;
    let chunks: Vec<Vec<u8>> = data.chunks(chunk_size).map(Vec::from).collect();

    // Generate proof from signer B (currently unstaked, but proof is still valid structurally)
    let signer_b_proof = generate_ingress_proof(
        &signer_b,
        tx.header.data_root,
        chunks.iter().map(|c| Ok(c.as_slice())),
        chain_id,
        anchor,
    )?;

    // Directly store signer B's proof in the database (bypassing the mempool ingestion check
    // which now rejects proofs from unstaked signers). This simulates a proof that was
    // stored when signer B was staked but is now in the DB after they unstaked.
    genesis_node.node_ctx.db.update(|rw_tx| {
        irys_database::store_external_ingress_proof_checked(
            rw_tx,
            &signer_b_proof,
            signer_b.address(),
        )
    })??;

    // Mine additional blocks to ensure tx anchor is old enough for inclusion
    // (tx anchor must be at least block_migration_depth=6 blocks behind current tip)
    // The tx will be auto-promoted during this mining when the anchor becomes valid
    genesis_node.mine_blocks(6).await?;

    // 6. Verify the tx was promoted and only staked signer's proof was included
    // Find the block that contains our tx in the publish ledger by searching the canonical chain
    let canonical_chain = genesis_node.get_canonical_chain();
    let promoted_entry = canonical_chain
        .iter()
        .find(|entry| {
            entry.header().data_ledgers[irys_types::DataLedger::Publish]
                .tx_ids
                .contains(&tx.header.id)
        })
        .expect("Transaction should have been promoted to a block");

    // Get the full block header to access the proofs
    let promoted_block = genesis_node
        .get_block_by_height(promoted_entry.height())
        .await
        .expect("Block at promoted height should exist");

    // Check that the block has publish ledger entries
    let publish_ledger = &promoted_block.data_ledgers[irys_types::DataLedger::Publish];
    assert!(
        publish_ledger.tx_ids.0.contains(&tx.header.id),
        "Transaction should be in the publish ledger of the promoting block"
    );

    // Verify the proofs in the block are only from staked signers
    let block_proofs = publish_ledger
        .proofs
        .as_ref()
        .expect("Block should have ingress proofs for the promoted transaction");

    for proof in block_proofs.0.iter() {
        let signer = proof.recover_signer()?;

        // Refresh epoch snapshot at the promoted height
        let epoch_snapshot_at_promotion = genesis_node
            .node_ctx
            .block_tree_guard
            .read()
            .get_epoch_snapshot(&promoted_block.block_hash())
            .expect("Should have epoch snapshot at promotion height");

        assert!(
            epoch_snapshot_at_promotion.is_staked(signer),
            "Block should only contain proofs from staked signers, but got proof from {:?}",
            signer
        );

        // Specifically, signer B's proof should NOT be included
        assert_ne!(
            signer,
            signer_b.address(),
            "Signer B's proof should be filtered out since they are unstaked"
        );
    }

    // We should have at least 1 proof (from genesis signer)
    assert!(
        !block_proofs.0.is_empty(),
        "Should have at least one proof from genesis signer"
    );

    genesis_node.stop().await;
    Ok(())
}

/// This test verifies that the mempool rejects ingress proofs from completely unstaked
/// signers (spam protection), but accepts proofs from signers with pending stake commitments.
#[test_log::test(tokio::test)]
async fn slow_heavy_mempool_rejects_unstaked_but_accepts_pending_stake_ingress_proofs(
) -> eyre::Result<()> {
    // 1. Setup: genesis node + two funded signers
    let mut genesis_config = NodeConfig::testing();
    genesis_config.consensus.get_mut().chunk_size = 32;
    let test_signer = genesis_config.new_random_signer();
    let pending_stake_signer = genesis_config.new_random_signer();
    genesis_config.fund_genesis_accounts(vec![&test_signer, &pending_stake_signer]);

    let genesis_node = IrysNodeTest::new_genesis(genesis_config.clone())
        .start_and_wait_for_packing("GENESIS", 20)
        .await;
    genesis_node.mine_block().await?;

    // 2. Post tx and upload chunks
    let data = vec![42_u8; 96];
    let tx = genesis_node
        .post_publish_data_tx(&test_signer, data.clone())
        .await?;
    genesis_node.upload_chunks(&tx).await?;
    genesis_node.wait_for_chunk_cache_count(3, 10).await?;

    // 3. Helper to generate proof
    let consensus = genesis_config.consensus_config();
    let chunk_size = consensus.chunk_size as usize;
    let chunks: Vec<Vec<u8>> = data.chunks(chunk_size).map(Vec::from).collect();
    let make_proof = |signer: &IrysSigner, anchor| {
        generate_ingress_proof(
            signer,
            tx.header.data_root,
            chunks.iter().map(|c| Ok(c.as_slice())),
            consensus.chain_id,
            anchor,
        )
    };

    // 4. Unstaked signer's proof should be REJECTED
    let anchor = genesis_node.get_anchor().await?;
    let result = genesis_node
        .ingest_ingress_proof(make_proof(&pending_stake_signer, anchor)?)
        .await;
    assert!(result.is_err(), "Should reject proof from unstaked signer");

    // 5. Signer stakes
    genesis_node
        .post_stake_commitment_with_signer(&pending_stake_signer)
        .await?;
    genesis_node.mine_block().await?;

    // 6. Now in commitment snapshot - proof should be ACCEPTED
    let new_anchor = genesis_node.get_anchor().await?;
    genesis_node
        .ingest_ingress_proof(make_proof(&pending_stake_signer, new_anchor)?)
        .await
        .expect("Should accept proof from signer with pending stake");

    genesis_node.stop().await;
    Ok(())
}
