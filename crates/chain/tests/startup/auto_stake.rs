use crate::utils::IrysNodeTest;
use irys_primitives::CommitmentType;
use irys_types::{CommitmentTransaction, NodeConfig, H256};
use rstest::rstest;
use tokio::task::yield_now;
use tracing::debug;

#[rstest]
#[case(false, 0)] // blank slate
#[case(true, 0)]
#[case(true, 1)]
#[case(true, 2)]
#[case(true, 3)]
// note: don't try to run the autogenerated test module manually, for whatever reason it fails (MDBX error code 12).
// but it works if you run each case separately
// TODO(maybe): Add support for checking the mempool for pending commitments? seems overkill.
// it would allow us to test non-zero pledge numbers without a stake
#[actix_web::test]
async fn test_auto_stake_pledge(#[case] stake: bool, #[case] pledges: usize) -> eyre::Result<()> {
    use irys_testing_utils::initialize_tracing;

    std::env::set_var("RUST_LOG", "debug,irys_database=off,irys_p2p::gossip_service=off,irys_actors::storage_module_service=off,trie=off,irys_reth::evm=off,engine::root=off,irys_p2p::peer_list=off,storage::db::mdbx=off,reth_basic_payload_builder=off,irys_gossip_service=off,providers::db=off,reth_payload_builder::service=off,irys_actors::broadcast_mining_service=off,reth_ethereum_payload_builder=off,provider::static_file=off,engine::persistence=off,provider::storage_writer=off,reth_engine_tree::persistence=off,irys_actors::cache_service=off,irys_vdf=off,irys_actors::block_tree_service=debug,irys_actors::vdf_service=off,rys_gossip_service::service=off,eth_ethereum_payload_builder=off,reth_node_events::node=off,reth::cli=off,reth_engine_tree::tree=off,irys_actors::ema_service=off,irys_efficient_sampling=off,hyper_util::client::legacy::connect::http=off,hyper_util::client::legacy::pool=off,irys_database::migration::v0_to_v1=off,irys_storage::storage_module=off,actix_server::worker=off,irys::packing::update=off,engine::tree=off,irys_actors::mining=error,payload_builder=off,irys_actors::reth_service=off,irys_actors::packing=off,irys_actors::reth_service=off,irys::packing::progress=off,irys_chain::vdf=off,irys_vdf::vdf_state=off");
    initialize_tracing();
    // Configure a test network with accelerated epochs (2 blocks per epoch)
    let num_blocks_in_epoch = 2;
    let seconds_to_wait = 20;
    let mut genesis_config = NodeConfig::testnet_with_epochs(num_blocks_in_epoch);
    genesis_config.consensus.get_mut().chunk_size = 32;

    // Create a signer (keypair) for the peer and fund it
    let peer_signer = genesis_config.new_random_signer();
    genesis_config.fund_genesis_accounts(vec![&peer_signer]);

    // Start the genesis node and wait for packing
    let genesis_node = IrysNodeTest::new_genesis(genesis_config.clone())
        .start_and_wait_for_packing("GENESIS", seconds_to_wait)
        .await;

    // Initialize the peer with our keypair/signer
    let mut peer_config = genesis_node.testnet_peer_with_signer(&peer_signer);
    peer_config.stake_pledge_drives = true;

    let mut already_processed_count = 0;
    let from_scratch_expected_count = 4;

    // so autopledge uses a different anchor
    let blk = genesis_node.mine_block().await?;
    genesis_node.wait_until_height(blk.height, 10).await?;

    if stake {
        let stake_tx = CommitmentTransaction {
            commitment_type: CommitmentType::Stake,
            // TODO: real staking amounts
            fee: 1,
            anchor: H256::zero(),
            ..Default::default()
        };
        let stake_tx = peer_signer.sign_commitment(stake_tx)?;

        genesis_node.post_commitment_tx(&stake_tx).await?;
        debug!("stake: {}", &stake_tx.id);
        // just the stake
        already_processed_count += 1;
        genesis_node
            .wait_for_mempool_shape(0, 0, already_processed_count, 10)
            .await?;
    }

    if pledges > 0 {
        let mut anchor = H256::zero();
        for _idx in 0..pledges {
            let stake_tx = CommitmentTransaction {
                commitment_type: CommitmentType::Pledge,
                // TODO: real staking amounts
                fee: 1,
                anchor,
                ..Default::default()
            };
            let pledge_tx = peer_signer.sign_commitment(stake_tx)?;
            debug!("pledge: {}", &pledge_tx.id);

            genesis_node.post_commitment_tx(&pledge_tx).await?;
            anchor = pledge_tx.id;
            already_processed_count += 1;
            // don't wait if we haven't posted a stake (stuck in the LRU)
            if stake {
                genesis_node
                    .wait_for_mempool_shape(0, 0, already_processed_count, 10)
                    .await?;
            } else {
                yield_now().await
            }
        }
    }

    // mine block 2
    let blk = genesis_node.mine_block().await?;
    genesis_node.wait_until_height(blk.height, 10).await?;

    // Start the peer
    let peer_node = IrysNodeTest::new(peer_config.clone())
        .start_with_name("PEER")
        .await;

    // wait for the expected txs to show up on the genesis node
    genesis_node
        .wait_for_mempool_shape(0, 0, from_scratch_expected_count, 10)
        .await?;

    // Mine a block to get the stake commitment included
    let irys_block1 = genesis_node.mine_block().await?;

    peer_node.wait_until_height(irys_block1.height, 10).await?;

    // Mine another block to verify the system continues to work
    let irys_block2 = genesis_node.mine_block().await?;

    peer_node.wait_until_height(irys_block2.height, 10).await?;

    // Get the genesis nodes view of the peers assignments
    let peer_assignments = genesis_node.get_partition_assignments(peer_signer.address());

    // Verify that the peer has the expected assignments (3)
    assert_eq!(peer_assignments.len(), 3);

    genesis_node.stop().await;
    peer_node.stop().await;

    Ok(())
}
