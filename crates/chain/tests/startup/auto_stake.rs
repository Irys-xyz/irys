use crate::utils::IrysNodeTest;
use irys_types::{VersionedCommitmentTransaction, NodeConfig};
use rstest::rstest;
use tokio::task::yield_now;
use tracing::debug;

// this test is designed to test how the automatic stake & pledge code functions when presented with a couple combinations of existing network conditions.
// the goal is to ensure that it doesn't stake or pledge unnecessarily when there are pre-existing stakes & pledges
#[rstest]
// (whether to start with a stake, number of pledges to start with) - this one is a blank slate
#[case(false, 0, false)]
#[case(true, 0, false)]
#[case(true, 1, false)]
#[case(true, 2, false)]
// all stakes & pledges already exist
#[case(true, 3, false)]
// test when starting up an epoch after initial submission
#[case(true, 3, true)]
#[case(true, 1, true)]
#[case(false, 0, true)]
// note: don't try to run the autogenerated test module manually, for whatever reason it fails (MDBX error code 12).
// but it works if you run each case separately
#[actix_web::test]
async fn test_auto_stake_pledge(
    #[case] stake: bool,
    #[case] pledges: usize,
    #[case] after_epoch: bool,
) -> eyre::Result<()> {
    use std::sync::Arc;

    use irys_testing_utils::initialize_tracing;
    use irys_types::U256;

    std::env::set_var("RUST_LOG", "debug,irys_database=off,irys_actors::storage_module_service=off,trie=off,irys_reth::evm=off,engine::root=off,storage::db::mdbx=off,reth_basic_payload_builder=off,providers::db=off,reth_payload_builder::service=off,irys_actors::broadcast_mining_service=off,reth_ethereum_payload_builder=off,provider::static_file=off,engine::persistence=off,provider::storage_writer=off,reth_engine_tree::persistence=off,irys_actors::cache_service=off,irys_vdf=off,irys_actors::vdf_service=off,eth_ethereum_payload_builder=off,reth_node_events::node=off,reth::cli=off,reth_engine_tree::tree=off,irys_actors::ema_service=off,irys_efficient_sampling=off,hyper_util::client::legacy::connect::http=off,hyper_util::client::legacy::pool=off,irys_database::migration::v0_to_v1=off,irys_storage::storage_module=off,actix_server::worker=off,irys::packing::update=off,engine::tree=off,irys_actors::mining=error,payload_builder=off,irys_actors::reth_service=off,irys_actors::packing=off,irys_actors::reth_service=off,irys::packing::progress=off,irys_chain::vdf=off,irys_vdf::vdf_state=off,irys_p2p::peer_list=error");
    initialize_tracing();
    // Configure a test network with accelerated epochs (3 blocks per epoch)

    let num_blocks_in_epoch = 3;
    let seconds_to_wait = 20;
    let mut genesis_config = NodeConfig::testing_with_epochs(num_blocks_in_epoch);
    genesis_config.consensus.get_mut().chunk_size = 32;

    // Create a signer (keypair) for the peer and fund it
    let peer_signer = genesis_config.new_random_signer();
    genesis_config.fund_genesis_accounts(vec![&peer_signer]);

    // Start the genesis node and wait for packing
    let genesis_node = IrysNodeTest::new_genesis(genesis_config.clone())
        .start_and_wait_for_packing("GENESIS", seconds_to_wait)
        .await;

    // Initialize the peer with our keypair/signer
    let mut peer_config = genesis_node.testing_peer_with_signer(&peer_signer);
    peer_config.stake_pledge_drives = true;

    let mut already_processed_count = 0;
    let from_scratch_expected_count = 4;

    // so autopledge uses a different anchor
    let blk = genesis_node.mine_block().await?;
    genesis_node.wait_until_height(blk.height, 10).await?;

    let config = genesis_node.node_ctx.config.consensus.clone();

    if stake {
        let stake_tx = VersionedCommitmentTransaction::new_stake(&config, genesis_node.get_anchor().await?);
        let stake_tx = peer_signer.sign_commitment(stake_tx)?;

        genesis_node.post_commitment_tx(&stake_tx).await?;
        debug!("stake: {}", &stake_tx.id);
        // just the stake
        already_processed_count += 1;
        genesis_node
            .wait_for_mempool_best_txs_shape(0, 0, already_processed_count, 10)
            .await?;
    }

    if pledges > 0 {
        let mut prev_price = U256::MAX;
        for _idx in 0..pledges {
            let tx = genesis_node
                .post_pledge_commitment_with_signer(&peer_signer)
                .await;
            assert!(
                tx.value < prev_price,
                "the price we pay for a pledge should go down with every tx"
            );
            prev_price = tx.value;
            already_processed_count += 1;
            // don't wait if we haven't posted a stake (stuck in the LRU)
            if stake {
                genesis_node
                    .wait_for_mempool_best_txs_shape(0, 0, already_processed_count, 10)
                    .await?;
            } else {
                yield_now().await
            }
        }
    }
    // mine an epoch block so that the commitments are well confirmed
    if after_epoch {
        genesis_node.mine_until_next_epoch().await?;
        genesis_node
            .wait_for_mempool_best_txs_shape(0, 0, 0, 10)
            .await?;
    }

    let tip_height = genesis_node.get_canonical_chain_height().await;
    let tip_block = genesis_node.get_block_by_height(tip_height).await?;

    // Start the peer
    let peer_node = IrysNodeTest::new(peer_config.clone())
        .start_with_name("PEER")
        .await;

    // gossip the block to the peer so it syncs up to the chain head
    genesis_node.gossip_block_to_peers(&Arc::new(tip_block))?;

    peer_node.wait_until_height(tip_height, 10).await?;

    // wait for the expected txs to show up on the genesis node
    genesis_node
        .wait_for_mempool_best_txs_shape(
            0,
            0,
            if after_epoch {
                from_scratch_expected_count - already_processed_count
            } else {
                from_scratch_expected_count
            },
            10,
        )
        .await?;

    // Mine the epoch block
    let (_, head_height) = genesis_node.mine_until_next_epoch().await?;

    peer_node.wait_until_height(head_height, 10).await?;

    // Get the genesis nodes view of the peers assignments
    let peer_assignments = genesis_node.get_partition_assignments(peer_signer.address());

    // Verify that the peer has the expected assignments (3)
    assert_eq!(peer_assignments.len(), 3);

    genesis_node.stop().await;
    peer_node.stop().await;

    Ok(())
}
