//! Irys payload types and attributes.
//!
//! This module contains the payload attribute types used for block building
//! and the Engine API.

use std::convert::Infallible;

use alloy_eips::{Encodable2718 as _, eip4895::Withdrawal, eip7685::Requests};
use alloy_primitives::{B256, U256};
use alloy_rpc_types::Withdrawals;
use alloy_rpc_types_engine::{ExecutionData, ExecutionPayload};
use reth::api::PayloadTypes;
use reth::payload::{EthBuiltPayload, EthPayloadBuilderAttributes};
use reth::primitives::{SealedBlock, SealedHeader};
use reth_chainspec::{EthChainSpec, EthereumHardforks};
use reth_engine_local::LocalPayloadAttributesBuilder;
use reth_ethereum_engine_primitives::EthPayloadAttributes;
use reth_ethereum_primitives::EthPrimitives;
use reth_node_api::{BuiltPayload, NodePrimitives, PayloadAttributes, PayloadBuilderAttributes};
use reth_payload_builder::PayloadId;
use reth_payload_primitives::BuiltPayloadExecutedBlock;
use reth_payload_primitives::PayloadAttributesBuilder;
use reth_transaction_pool::EthPooledTransaction;
use revm_primitives::Address;
use sha2::{Digest as _, Sha256};

/// RPC payload attributes for Irys.
///
/// Shadow transactions are passed directly as `EthPooledTransaction` internally.
#[derive(Debug, Clone, PartialEq, Eq, Default, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct IrysPayloadAttributes {
    #[serde(flatten)]
    pub inner: EthPayloadAttributes,
    /// Shadow transactions to include in the payload.
    /// Skipped in serialization as shadow txs are generated by the block producer,
    /// not received via RPC.
    #[serde(skip)]
    pub shadow_txs: Vec<EthPooledTransaction>,
}

impl PayloadAttributes for IrysPayloadAttributes {
    fn timestamp(&self) -> u64 {
        self.inner.timestamp
    }

    fn withdrawals(&self) -> Option<&Vec<Withdrawal>> {
        self.inner.withdrawals.as_ref()
    }

    fn parent_beacon_block_root(&self) -> Option<B256> {
        self.inner.parent_beacon_block_root
    }
}

/// Computes Irys payload ID including shadow transactions.
///
/// The payload ID is derived from the parent block hash, the payload attributes,
/// and the shadow transactions. This ensures that different shadow transactions
/// result in different payload IDs.
fn irys_payload_id(
    parent: &B256,
    attributes: &EthPayloadAttributes,
    shadow_txs: &[EthPooledTransaction],
) -> PayloadId {
    let mut hasher = Sha256::new();

    // Include standard Ethereum payload attributes
    hasher.update(parent.as_slice());
    hasher.update(&attributes.timestamp.to_be_bytes()[..]);
    hasher.update(attributes.prev_randao.as_slice());
    hasher.update(attributes.suggested_fee_recipient.as_slice());

    if let Some(withdrawals) = &attributes.withdrawals {
        // Encode withdrawals using RLP
        let mut buf = Vec::new();
        alloy_rlp::encode_list(withdrawals, &mut buf);
        hasher.update(&buf);
    }

    if let Some(parent_beacon_block) = attributes.parent_beacon_block_root {
        hasher.update(parent_beacon_block.as_slice());
    }

    // Include shadow transactions in the hash using EIP-2718 encoding
    for tx in shadow_txs {
        let mut buf = Vec::new();
        // Access the inner transaction to use Encodable2718
        tx.transaction().encode_2718(&mut buf);
        hasher.update(&buf);
    }

    let out = hasher.finalize();
    PayloadId::new(out.as_slice()[..8].try_into().expect("sufficient length"))
}

/// Container type for all components required to build a payload.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct IrysPayloadBuilderAttributes {
    pub inner: EthPayloadBuilderAttributes,
    /// Shadow transactions to include in the payload
    pub shadow_txs: Vec<EthPooledTransaction>,
    /// Custom payload ID that includes shadow transactions
    pub id: PayloadId,
}

impl Default for IrysPayloadBuilderAttributes {
    fn default() -> Self {
        let inner = EthPayloadBuilderAttributes::default();
        Self {
            id: inner.id,
            inner,
            shadow_txs: Vec::new(),
        }
    }
}

impl PayloadBuilderAttributes for IrysPayloadBuilderAttributes {
    type RpcPayloadAttributes = IrysPayloadAttributes;
    type Error = Infallible;

    /// Creates a new payload builder for the given parent block and the attributes.
    ///
    /// Derives the unique [`PayloadId`] for the given parent and attributes,
    /// including shadow transactions in the hash computation.
    fn try_new(
        parent: B256,
        attributes: IrysPayloadAttributes,
        _version: u8,
    ) -> Result<Self, Infallible> {
        // Compute custom payload ID including shadow transactions
        let id = irys_payload_id(&parent, &attributes.inner, &attributes.shadow_txs);
        let mut inner = EthPayloadBuilderAttributes::new(parent, attributes.inner);
        inner.id = id;

        Ok(Self {
            inner,
            shadow_txs: attributes.shadow_txs,
            id,
        })
    }

    fn payload_id(&self) -> PayloadId {
        self.id
    }

    fn parent(&self) -> B256 {
        self.inner.parent
    }

    fn timestamp(&self) -> u64 {
        self.inner.timestamp
    }

    fn parent_beacon_block_root(&self) -> Option<B256> {
        self.inner.parent_beacon_block_root
    }

    fn suggested_fee_recipient(&self) -> Address {
        self.inner.suggested_fee_recipient
    }

    fn prev_randao(&self) -> B256 {
        self.inner.prev_randao
    }

    fn withdrawals(&self) -> &Withdrawals {
        &self.inner.withdrawals
    }
}

/// Irys-specific built payload that includes treasury balance.
///
/// Treasury balance is extracted from EVM state after transaction execution,
/// before the state is committed to the canonical chain. This allows us to
/// pass the treasury balance to the block producer without waiting for the
/// Fork Choice Update (FCU).
#[derive(Debug, Clone)]
pub struct IrysBuiltPayload {
    /// The inner Ethereum built payload
    inner: EthBuiltPayload,
    /// Final treasury balance after all transactions in this block
    treasury_balance: U256,
}

impl IrysBuiltPayload {
    /// Create a new IrysBuiltPayload
    pub fn new(inner: EthBuiltPayload, treasury_balance: U256) -> Self {
        Self {
            inner,
            treasury_balance,
        }
    }

    /// Get the inner EthBuiltPayload
    pub fn inner(&self) -> &EthBuiltPayload {
        &self.inner
    }

    /// Get the treasury balance
    pub fn treasury_balance(&self) -> U256 {
        self.treasury_balance
    }

    /// Consume self and return the inner EthBuiltPayload
    pub fn into_inner(self) -> EthBuiltPayload {
        self.inner
    }

    /// Get the block from the inner payload
    pub fn block(&self) -> &SealedBlock<<EthPrimitives as NodePrimitives>::Block> {
        self.inner.block()
    }

    /// Get the fees from the inner payload
    pub fn fees(&self) -> U256 {
        self.inner.fees()
    }
}

impl BuiltPayload for IrysBuiltPayload {
    type Primitives = EthPrimitives;

    fn block(&self) -> &SealedBlock<<Self::Primitives as NodePrimitives>::Block> {
        self.inner.block()
    }

    fn fees(&self) -> U256 {
        self.inner.fees()
    }

    fn executed_block(&self) -> Option<BuiltPayloadExecutedBlock<Self::Primitives>> {
        self.inner.executed_block()
    }

    fn requests(&self) -> Option<Requests> {
        self.inner.requests()
    }
}

/// A default payload type for [`IrysPayloadTypes`]
#[derive(Debug, Default, Clone, serde::Deserialize, serde::Serialize)]
#[non_exhaustive]
pub struct IrysPayloadTypes;

impl PayloadTypes for IrysPayloadTypes {
    type BuiltPayload = IrysBuiltPayload;
    type PayloadAttributes = IrysPayloadAttributes;
    type PayloadBuilderAttributes = IrysPayloadBuilderAttributes;
    type ExecutionData = ExecutionData;

    fn block_to_payload(
        block: SealedBlock<
            <<Self::BuiltPayload as BuiltPayload>::Primitives as NodePrimitives>::Block,
        >,
    ) -> Self::ExecutionData {
        let (payload, sidecar) =
            ExecutionPayload::from_block_unchecked(block.hash(), &block.into_block());
        ExecutionData { payload, sidecar }
    }
}

/// Implement PayloadAttributesBuilder for LocalPayloadAttributesBuilder to support IrysPayloadAttributes
impl<CS> PayloadAttributesBuilder<IrysPayloadAttributes, CS::Header>
    for LocalPayloadAttributesBuilder<CS>
where
    CS: EthChainSpec + EthereumHardforks + Send + Sync + 'static,
{
    fn build(&self, parent: &SealedHeader<CS::Header>) -> IrysPayloadAttributes {
        IrysPayloadAttributes {
            inner: <Self as PayloadAttributesBuilder<EthPayloadAttributes, CS::Header>>::build(
                self, parent,
            ),
            shadow_txs: vec![],
        }
    }
}

// ==========================================
// TryFrom implementations for ExecutionPayload types
// ==========================================
//
// These implementations are required by EthEngineTypes<IrysPayloadTypes> to satisfy
// the EngineTypes trait bounds (which require TryInto). We delegate to the inner EthBuiltPayload.

use alloy_rpc_types_engine::{
    ExecutionPayloadEnvelopeV2, ExecutionPayloadEnvelopeV3, ExecutionPayloadEnvelopeV4,
    ExecutionPayloadEnvelopeV5, ExecutionPayloadEnvelopeV6, ExecutionPayloadV1,
};
use reth_ethereum_engine_primitives::BuiltPayloadConversionError;

// V1 and V2 use From since they can't fail
impl From<IrysBuiltPayload> for ExecutionPayloadV1 {
    fn from(value: IrysBuiltPayload) -> Self {
        value.inner.into()
    }
}

impl From<IrysBuiltPayload> for ExecutionPayloadEnvelopeV2 {
    fn from(value: IrysBuiltPayload) -> Self {
        value.inner.into()
    }
}

// V3, V4, V5 use TryFrom since blob sidecar conversion can fail
impl TryFrom<IrysBuiltPayload> for ExecutionPayloadEnvelopeV3 {
    type Error = BuiltPayloadConversionError;

    fn try_from(value: IrysBuiltPayload) -> Result<Self, Self::Error> {
        value.inner.try_into()
    }
}

impl TryFrom<IrysBuiltPayload> for ExecutionPayloadEnvelopeV4 {
    type Error = BuiltPayloadConversionError;

    fn try_from(value: IrysBuiltPayload) -> Result<Self, Self::Error> {
        value.inner.try_into()
    }
}

impl TryFrom<IrysBuiltPayload> for ExecutionPayloadEnvelopeV5 {
    type Error = BuiltPayloadConversionError;

    fn try_from(value: IrysBuiltPayload) -> Result<Self, Self::Error> {
        value.inner.try_into()
    }
}

impl TryFrom<IrysBuiltPayload> for ExecutionPayloadEnvelopeV6 {
    type Error = BuiltPayloadConversionError;

    fn try_from(value: IrysBuiltPayload) -> Result<Self, Self::Error> {
        value.inner.try_into()
    }
}
