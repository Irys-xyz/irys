//! Irys payload types and attributes.
//!
//! This module contains the payload attribute types used for block building
//! and the Engine API.

use std::convert::Infallible;

use alloy_eips::{Encodable2718 as _, eip4895::Withdrawal};
use alloy_primitives::B256;
use alloy_rpc_types::Withdrawals;
use alloy_rpc_types_engine::{ExecutionData, ExecutionPayload};
use reth::api::PayloadTypes;
use reth::payload::{EthBuiltPayload, EthPayloadBuilderAttributes};
use reth::primitives::SealedBlock;
use reth_chainspec::EthereumHardforks;
use reth_engine_local::LocalPayloadAttributesBuilder;
use reth_ethereum_engine_primitives::EthPayloadAttributes;
use reth_node_api::{BuiltPayload, NodePrimitives, PayloadAttributes, PayloadBuilderAttributes};
use reth_payload_builder::PayloadId;
use reth_payload_primitives::PayloadAttributesBuilder;
use reth_transaction_pool::EthPooledTransaction;
use revm_primitives::Address;
use sha2::{Digest as _, Sha256};

/// RPC payload attributes for Irys.
///
/// Shadow transactions are passed directly as `EthPooledTransaction` internally.
#[derive(Debug, Clone, PartialEq, Eq, Default, serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct IrysPayloadAttributes {
    #[serde(flatten)]
    pub inner: EthPayloadAttributes,
    /// Shadow transactions to include in the payload.
    /// Skipped in serialization as shadow txs are generated by the block producer,
    /// not received via RPC.
    #[serde(skip)]
    pub shadow_txs: Vec<EthPooledTransaction>,
}

impl PayloadAttributes for IrysPayloadAttributes {
    fn timestamp(&self) -> u64 {
        self.inner.timestamp
    }

    fn withdrawals(&self) -> Option<&Vec<Withdrawal>> {
        self.inner.withdrawals.as_ref()
    }

    fn parent_beacon_block_root(&self) -> Option<B256> {
        self.inner.parent_beacon_block_root
    }
}

/// Computes Irys payload ID including shadow transactions.
///
/// The payload ID is derived from the parent block hash, the payload attributes,
/// and the shadow transactions. This ensures that different shadow transactions
/// result in different payload IDs.
fn irys_payload_id(
    parent: &B256,
    attributes: &EthPayloadAttributes,
    shadow_txs: &[EthPooledTransaction],
) -> PayloadId {
    let mut hasher = Sha256::new();

    // Include standard Ethereum payload attributes
    hasher.update(parent.as_slice());
    hasher.update(&attributes.timestamp.to_be_bytes()[..]);
    hasher.update(attributes.prev_randao.as_slice());
    hasher.update(attributes.suggested_fee_recipient.as_slice());

    if let Some(withdrawals) = &attributes.withdrawals {
        // Encode withdrawals using RLP
        let mut buf = Vec::new();
        alloy_rlp::encode_list(withdrawals, &mut buf);
        hasher.update(&buf);
    }

    if let Some(parent_beacon_block) = attributes.parent_beacon_block_root {
        hasher.update(parent_beacon_block.as_slice());
    }

    // Include shadow transactions in the hash using EIP-2718 encoding
    for tx in shadow_txs {
        let mut buf = Vec::new();
        // Access the inner transaction to use Encodable2718
        tx.transaction().encode_2718(&mut buf);
        hasher.update(&buf);
    }

    let out = hasher.finalize();
    PayloadId::new(out.as_slice()[..8].try_into().expect("sufficient length"))
}

/// Container type for all components required to build a payload.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct IrysPayloadBuilderAttributes {
    pub inner: EthPayloadBuilderAttributes,
    /// Shadow transactions to include in the payload
    pub shadow_txs: Vec<EthPooledTransaction>,
    /// Custom payload ID that includes shadow transactions
    pub id: PayloadId,
}

impl Default for IrysPayloadBuilderAttributes {
    fn default() -> Self {
        let inner = EthPayloadBuilderAttributes::default();
        Self {
            id: inner.id,
            inner,
            shadow_txs: Vec::new(),
        }
    }
}

impl PayloadBuilderAttributes for IrysPayloadBuilderAttributes {
    type RpcPayloadAttributes = IrysPayloadAttributes;
    type Error = Infallible;

    /// Creates a new payload builder for the given parent block and the attributes.
    ///
    /// Derives the unique [`PayloadId`] for the given parent and attributes,
    /// including shadow transactions in the hash computation.
    fn try_new(
        parent: B256,
        attributes: IrysPayloadAttributes,
        _version: u8,
    ) -> Result<Self, Infallible> {
        // Compute custom payload ID including shadow transactions
        let id = irys_payload_id(&parent, &attributes.inner, &attributes.shadow_txs);
        let mut inner = EthPayloadBuilderAttributes::new(parent, attributes.inner);
        inner.id = id;

        Ok(Self {
            inner,
            shadow_txs: attributes.shadow_txs,
            id,
        })
    }

    fn payload_id(&self) -> PayloadId {
        self.id
    }

    fn parent(&self) -> B256 {
        self.inner.parent
    }

    fn timestamp(&self) -> u64 {
        self.inner.timestamp
    }

    fn parent_beacon_block_root(&self) -> Option<B256> {
        self.inner.parent_beacon_block_root
    }

    fn suggested_fee_recipient(&self) -> Address {
        self.inner.suggested_fee_recipient
    }

    fn prev_randao(&self) -> B256 {
        self.inner.prev_randao
    }

    fn withdrawals(&self) -> &Withdrawals {
        &self.inner.withdrawals
    }
}

/// A default payload type for [`IrysPayloadTypes`]
#[derive(Debug, Default, Clone, serde::Deserialize, serde::Serialize)]
#[non_exhaustive]
pub struct IrysPayloadTypes;

impl PayloadTypes for IrysPayloadTypes {
    type BuiltPayload = EthBuiltPayload;
    type PayloadAttributes = IrysPayloadAttributes;
    type PayloadBuilderAttributes = IrysPayloadBuilderAttributes;
    type ExecutionData = ExecutionData;

    fn block_to_payload(
        block: SealedBlock<
            <<Self::BuiltPayload as BuiltPayload>::Primitives as NodePrimitives>::Block,
        >,
    ) -> Self::ExecutionData {
        let (payload, sidecar) =
            ExecutionPayload::from_block_unchecked(block.hash(), &block.into_block());
        ExecutionData { payload, sidecar }
    }
}

/// Implement PayloadAttributesBuilder for LocalPayloadAttributesBuilder to support IrysPayloadAttributes
impl<CS> PayloadAttributesBuilder<IrysPayloadAttributes> for LocalPayloadAttributesBuilder<CS>
where
    CS: EthereumHardforks + Send + Sync + 'static,
{
    fn build(&self, timestamp: u64) -> IrysPayloadAttributes {
        IrysPayloadAttributes {
            inner: <Self as PayloadAttributesBuilder<EthPayloadAttributes>>::build(self, timestamp),
            shadow_txs: vec![],
        }
    }
}
