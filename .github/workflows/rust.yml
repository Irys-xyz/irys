name: Rust Checks

permissions:
  contents: read

concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

on:
  pull_request:
  merge_group:
  push:
  workflow_dispatch:

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  gate:
    name: gate
    runs-on: self-hosted
    outputs:
      should-run: ${{ steps.set-output.outputs.should-run }}  # register we have some output other actions should reference
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0  # Need full history for comparison
        # this script checks whether we should run on the current commit, based on:
        # 1.) if it's a push event (new commit) and the special `#disable-ci` string isn't present in the commit message
        # 2.) if the commit is a pull request, that the base branch has some number of changes 
        #     (this is to prevent CI running twice, one for the current branch and one for the merge between the current and base branches, if the base branch has no commits ahead of the current)
        # 3.) if the commit is to the `default` branch (in our case `master`), CI is ALWAYS run
        # 4.) if the event is a workflow_dispatch (manual trigger/failsafe)
      - name: Check if CI should run
        id: set-output
        run: | 
          # default to running
          SHOULD_RUN=true
          
          # check if CI is disabled in the commit message
          if [[ "${{ github.event_name }}" == "push" && "${{ contains(github.event.head_commit.message, '#disable-ci') }}" == "true" ]]; then
            SHOULD_RUN=false
          fi
          
          # for pull request events, check if base branch has commits ahead of head branch
          # this is so we can skip uneeded tests if we're in sync already
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            git fetch origin ${{ github.event.pull_request.base.ref }}:base_branch
            git fetch origin ${{ github.event.pull_request.head.ref }}:head_branch
            
            # check if base branch has commits that head branch doesn't have (so we can test against the auto merge)
            AHEAD_COMMITS=$(git rev-list --count head_branch..base_branch)
            
            if [[ $AHEAD_COMMITS -eq 0 ]]; then
              echo "base branch is not ahead of head branch, skipping..."
              SHOULD_RUN=false
            else
              echo "base branch is ahead of head branch by $AHEAD_COMMITS commits, running..."
            fi
          fi
          
          # always run on the default branch
          if [[ "${{ github.ref }}" == "refs/heads/${{ github.event.repository.default_branch }}" ]]; then
            SHOULD_RUN=true
          fi
          
          # always run on workflow_dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            SHOULD_RUN=true
          fi

          # write output to the action output file
          echo "should-run=${SHOULD_RUN}" >> $GITHUB_OUTPUT

  cargo-test:
    name: cargo test
    runs-on: [self-hosted, test-runner]
    needs: gate
    if: ${{ needs.gate.outputs.should-run == 'true' }}
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup repo
        uses: ./.github/actions/setup-repo
      - uses: taiki-e/install-action@nextest

      - name: cargo test
        run: RUST_LOG=debug cargo xtask test

  cargo-check:
    name: cargo check
    runs-on: self-hosted
    needs: gate
    if: ${{ needs.gate.outputs.should-run == 'true' }}
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup repo
        uses: ./.github/actions/setup-repo

      - name: Update submodules
        run: git submodule update --init --recursive

      - name: cargo check
        run: RUSTFLAGS="-D warnings" cargo xtask full-check

  cargo-fmt:
    name: cargo fmt
    runs-on: self-hosted
    needs: gate
    if: ${{ needs.gate.outputs.should-run == 'true' }}
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup repo
        uses: ./.github/actions/setup-repo

      - name: cargo fmt
        run: cargo xtask fmt --check-only

  cargo-clippy:
    name: cargo clippy
    runs-on: self-hosted
    needs: gate
    if: ${{ needs.gate.outputs.should-run == 'true' }}
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup repo
        uses: ./.github/actions/setup-repo

      - name: cargo clippy
        run: cargo xtask clippy -- --all-features

  cargo-doc:
    name: cargo doc
    runs-on: self-hosted
    needs: gate
    if: ${{ needs.gate.outputs.should-run == 'true' }}
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup repo
        uses: ./.github/actions/setup-repo

      - name: cargo doc
        run: cargo xtask doc -- --all-features

      - name: cargo test docs
        run: RUST_LOG=debug cargo test --doc

  cargo-unused-deps:
    name: cargo unused-deps
    runs-on: self-hosted
    needs: gate
    if: ${{ needs.gate.outputs.should-run == 'true' }}
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
          fetch-depth: 0

      - name: Setup repo
        uses: ./.github/actions/setup-repo

      - name: cargo unused deps
        run: cargo xtask unused-deps

  typos:
    runs-on: self-hosted
    needs: gate
    if: ${{ needs.gate.outputs.should-run == 'true' }}
    timeout-minutes: 30
    steps:
      - uses: actions/checkout@v4
      - uses: crate-ci/typos@v1.29.7
        with:
          files: .
